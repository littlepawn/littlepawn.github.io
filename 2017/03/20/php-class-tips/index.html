<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="pawn"><title>php类相关 · 小丝の随笔</title><meta name="description" content="类的成员属性(属性的称呼相对于“方法”而言)包括类常量和类变量，其中类常量在定义时不可为空，类的属性在定义时如果被赋值，只能使用标量和数组，并且不能是表达式，因为类属性在编译期被初始化，PHP 在编译期不执行表达式。

public：可以继承，可以在类的方法之外被访问 , 如 $obj-&amp;gt;pr"><meta name="keywords" content="Hexo,HTML,php,linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">小丝の随笔</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/u/3547528514/"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Author by </span></a><a target="_blank" href="/"> Pawn</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://182.254.245.16/timg.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>php类相关</a></h3></div><div class="post-content"><ol>
<li><p>类的成员属性(属性的称呼相对于“方法”而言)包括类常量和类变量，其中类常量在定义时不可为空，<em>类的属性在定义时如果被赋值，只能使用标量和数组，并且不能是表达式，因为类属性在编译期被初始化，PHP 在编译期不执行表达式</em>。</p>
</li>
<li><p>public：可以继承，可以在类的方法之外被访问 , 如 $obj-&gt;prop;<br>protected：可以继承，不可以在类的方法之外被访问<br>private：不可以继承，不可以在类的方法之外访问<br><strong>tips:这三个访问控制关键字也可以修饰构造函数，当 private 和 protected 修饰类的构造函数时，你只能通过一个 publice static 的静态方法来调用构造函数以实例化对象，因为该函数无法在类之外被访问了，比如，单例类的实现：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">    private static $instance=null;</div><div class="line">    public $k = 88;</div><div class="line">    private function __construct()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function getInstance()&#123;</div><div class="line">        if(self::$instance==null)&#123;</div><div class="line">                self::$instance = new self();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return self::$instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function  __clone()&#123; //pretend clone oprationg</div><div class="line">        throw(&apos;Singleton class can not be cloned&apos;);</div><div class="line">        return self::getInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//new Singleton();  // Error</div><div class="line">$in = Singleton::getInstance();</div></pre></td></tr></table></figure>
</li>
<li><p>继承禁止： final 关键字，仅用于修饰类或类的方法<br> 如果一个类被 final 修饰，这个类不能被继承，如果一个方法被final 修饰，则这个方法不能被子类重写(override)。</p>
</li>
<li><p>抽象类和抽象方法：abstract 仅用于 类和方法，抽象类不能直接用于实例化对象只能用于产生子类<br> <strong>tips:抽象类可以有具体实现的方法，接口无</strong></p>
</li>
<li><p>类的常量及其访问：类的常量不能使用访问限制修饰符，<em>他是 public 的，可继承，可以被子类重写</em>，访问类的常量必须使用双冒号 :: ，可以使用类名或类的实例来访问，因为是常量，所以名称不能使用表示变量的符号 $ 。</p>
</li>
<li><p>类的静态成员及访问，static 可 以修饰类的属性及方法，被 static 修饰的成员归属于类而非类的实例，静态成员必须使用类名加双冒号 :: 来访问， 因为在实例化对象之前 静 态成员就存在了，因此，在静态方法内，禁止使用指向实例本身的伪变量 $this(或习惯上称为 $this 指针) ，可以使用关键字 self 代替 类名(相当于类的魔术常量  <strong>CLASS</strong>)。<strong>static 不能用于修饰 类的构造函数，也不能用于修饰接口声明的方法。</strong><br>tips:</p>
<ul>
<li><p>静态成员可以使用 访问控制关键字修饰，可以被继承和重写，需要注意的是，如果一个子类继承了父类的静态方法（没有重写该方法），那么子类调用的实际是父类的静态方法。因为静态成员持有者是类不是对象，所以类的多个实例是共享同一个静态属性的，在一个实例中修改静态属性会影响到另一个实例中的静态属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">   public static $a1 = 11;</div><div class="line">   public $a2 = 22;</div><div class="line">   public static function showStatic()&#123;</div><div class="line">       return  self::$a1;</div><div class="line">   &#125;</div><div class="line">   public function getStatic()&#123;</div><div class="line">       return self::$a1;</div><div class="line">   &#125;</div><div class="line">   public function getClassStatic()&#123;</div><div class="line">       $className = get_called_class();</div><div class="line">       return  $className::$a1;</div><div class="line">   &#125;</div><div class="line">   public function getProp()&#123;</div><div class="line">       return $this-&gt;a2;</div><div class="line">   &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A&#123;    </div><div class="line">   public static $a1 = 88;</div><div class="line">   public $a2 = 99;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj1 = new A();</div><div class="line">$obj2 = new B();</div><div class="line"> </div><div class="line">echo A::showStatic(); //11</div><div class="line">echo $obj1-&gt;getStatic(); //11</div><div class="line">echo $obj1-&gt;getClassStatic(); //11</div><div class="line">echo $obj1-&gt;getProp(); //22</div><div class="line">echo B::showStatic(); //11 调用的是父类的方法，访问父类的静态成员</div><div class="line">echo $obj2-&gt;getStatic(); //11 调用的是父类的方法，方法中的 self 指向持有该静态方法的类</div><div class="line">echo $obj2-&gt;getClassStatic(); //88	</div><div class="line">echo $obj2-&gt;getProp(); //99</div></pre></td></tr></table></figure>
</li>
<li><p>后期静态绑定：为了避免子类重写静态属性后，使用继承来的方法仍然访问父类的静态属性， PHP5.3  增加了一个新的语法：后期静态绑定，使用 static 关键字替代 self 关键字，使得 static 指向与  get_called_class() 返回的相同的类，即当前调用该静态方法的对象所属的类，该关键字对于 静态方法的访问同样有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public function getClassStatic()&#123;</div><div class="line">     $className = get_called_class();  </div><div class="line">     return  $className::$a1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//可以写成 :</div><div class="line">public function getClassStatic()&#123;    </div><div class="line">   return  static::$a1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">//用于静态方法</div><div class="line">//A类中：</div><div class="line">public static function testStatic()&#123;</div><div class="line">   echo &quot;&lt;p&gt;testStatic of A &lt;/p&gt;&quot;;</div><div class="line">&#125;</div><div class="line">public function callStatic()&#123;</div><div class="line">   static::testStatic();</div><div class="line">&#125;</div><div class="line">	</div><div class="line">//B类中：</div><div class="line">public static function testStatic()&#123;</div><div class="line">   echo &quot;&lt;p&gt;testStatic of B &lt;/p&gt;&quot;;</div><div class="line">&#125;</div><div class="line">//B类继承A类的 callStatic 方法，可以正确访问各自类的 testStatic 方法。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类的方法中几个指向类或实例的关键字</p>
<ul>
<li>$this-&gt;propName   $this 指向类的实例 </li>
<li>parent::xxx  parent 指向父类，可以访问父类的静态常量、静态属性(parent::$xxx) ,不能访问父类的非静态属性 ,可以调用父类的方法(不能是 private 方法，无论是否静态)</li>
<li>self::xxx  self 指向定义了当前被调用的方法的类，用于访问静态成员和类的常量</li>
<li>static::xxx 访问实例化了调用当前方法的实例的那个类，用于访问静态成员和累的常量，他跟 self 的差别是访问静态成员时采用 “后期静态绑定”</li>
</ul>
</li>
<li><p>接口定义</p>
<ul>
<li>类在实现接口的方法时，这些方法也必须是 public 的，具体实现的（不能是 abstract )</li>
<li>接口也可以定义接口常量，用法与类常量完全一致，但是接口不可以定义非函数成员</li>
<li>接口与接口之间可以继承，接口的继承可以是多继承，用逗号隔开（字类与父类的继承是单继承的）</li>
<li>一个类可以实现多个接口，用逗号隔开</li>
</ul>
</li>
<li><p>类型约束</p>
<ul>
<li>PHP 的函数（或类的方法） 可以在声明时限定参数的类型，但只能 限定 array 或 object（class/interface） ，如果限定为 string 型， PHP 会认为是限定为一个 string 类 的 object 参数。</li>
<li>如果类型被限定为某个接口，则传入的参数必须是实现该接口的类的实例。</li>
<li>在接口实现、子类重写父类方法时，不能修改已经限定的参数类型。</li>
<li>在方法、函数调用时，如果传入了与限定的参数类型不同的数据将会报错，但是可以接受  null 参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Im&#123;</div><div class="line">   public function a( classm $m);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A implements Im&#123;</div><div class="line">    public function a($x)&#123;   // error ，参数$x必须限定为 classm 类型以匹配接口的定义</div><div class="line">       var_dump($x)；</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-03-20</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://yoursite.com/2017/03/20/php-class-tips/,小丝の随笔,php类相关,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/03/21/mysql/" title="mysql函数及语法" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/03/17/docker-install/" title="docker配置" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>